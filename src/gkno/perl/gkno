#!/usr/bin/perl -W

use strict;
use Cwd 'abs_path';
use File::Find;
use FindBin;

# Include source files.
my $cwd        = abs_path(".");
my $sourcePath = abs_path($0);
$sourcePath =~ s/\/gkno$//;

# Include links to required packages.
require "$sourcePath/src/gkno/commandLine.pm";
require "$sourcePath/src/gkno/json.pm";
require "$sourcePath/src/gkno/pipelines.pm";
require "$sourcePath/src/gkno/tools.pm";

# Find the current time.  This will be used in generating
# file names as well as for printout to output files.

(my $time, my $day, my $month, my $year) = tools::findTime();

# Each of the tools available to gkno should have a config file to
# describe its operation, purpose etc.  These are contained in
# config_files/tools.  Find all of the config file and create a hash
# table with all available tools.
my $toolConfigFiles = tools::getJsonFiles("$sourcePath/config_files/tools");
my $rTools          = tools::getToolDescriptions($sourcePath, $toolConfigFiles);

# Get the first command line argument and proceed as required.
my $mode = commandLine::getMode($rTools);

# If a pipeline is being run, check that configuration files
# exist for the selected pipeline.  This should be in directory
# config_files and have the name <$ARGV[1]>.json.
if ($mode eq "pipe") {
  my $pipelineConfig = pipelines::getPipelineConfig($sourcePath);
  open(my $pipeHandle, "<$pipelineConfig");
  my $string    = json::fileToString($pipelineConfig, $pipeHandle);
  my $rPipe     = json::evaluateString($string);
  close($pipeHandle);

  # Print information about the pipeline to screen.
  pipelines::information($time, $rPipe, $rTools);

  # For each of the tools, parse the allowed command line options
  # and populate non-silent options with their default values.
  my $toolOptions = commandLine::setupToolOptions($rPipe, $rTools);

  # Now check if the pipeline config file updates any of the default
  # values.
  pipelines::updateOptions($toolOptions, $rTools, $rPipe);

  # Parse command line options and override any variables with these
  # values.
  my $setOptions = commandLine::parseCommandLine($rTools, $rPipe, $toolOptions);
  commandLine::toolCommands($sourcePath, $toolOptions, $setOptions, $rTools);

  # Check that tha pipeline flow makes sense (i.e. the input file of
  # each component is consistent with the output file of the
  # previous component).  Simultaneously, build up the flow of files
  # from one program to the next.
  pipelines::checkFlowConsistency($rPipe, $rTools);

  # Generate scripts to run the selected pipeline.
  pipelines::generateMakefile($sourcePath, $rPipe, $rTools, $toolOptions);

# If an individual tool was selected, create a script to run the
# tool.
} else {
}
